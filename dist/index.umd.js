!function(t,s){"object"==typeof exports&&"undefined"!=typeof module?s(exports):"function"==typeof define&&define.amd?define(["exports"],s):s((t="undefined"!=typeof globalThis?globalThis:t||self).MyLib={})}(this,function(t){"use strict";class s{constructor(t){this.result=null,this.error=null,this.isCompleted=!1,this.isRunning=!1,this.time=0,this.completeCallback=()=>{},this.id=t.id,this.tag=t.tag,this.params=t.params,this.taskFunction=t.taskFunction}async run(){const t=Date.now();try{this.isRunning=!0,this.result=await this.taskFunction(...this.params)}catch(t){this.error=t}finally{this.isRunning=!1,this.isCompleted=!0,this.time=Date.now()-t,this.completeCallback(this)}}onComplete(t){this.completeCallback=t}}class e{constructor(t=[]){this.tasks=t}create(t){const e=new s(t);return this.tasks.push(e),e}add(t){this.tasks.push(t)}pop(){return this.tasks.shift()||null}removeById(t){this.tasks=this.tasks.filter(s=>s.id!==t)}removeByTag(t){this.tasks=this.tasks.filter(s=>s.tag!==t)}remove(t){this.tasks=this.tasks.filter(s=>s!==t)}clear(){this.tasks=[]}}class i{constructor(t=new e,s=1){this.taskQueue=t,this.concurrency=s,this.isStopped=!1,this.stopReslove=null,this.pool=[],this.taskCompletedCallback=()=>{},this.allCompletedCallback=()=>{}}setConcurrency(t){this.concurrency=t,this.run()}setTaskCompletedCallback(t){this.taskCompletedCallback=t}setAllCompletedCallback(t){this.allCompletedCallback=t}run(){for(this.isStopped=!1;this.pool.length<this.concurrency;){const t=this.taskQueue.pop();if(!t)break;this.pool.push(t),t.onComplete(t=>{this.taskCompletedCallback(t),this.pool=this.pool.filter(s=>s!==t),this.isStopped?0===this.pool.length&&(this.stopReslove&&this.stopReslove(),this.stopReslove=null):this.taskQueue.tasks.length>0?this.run():0===this.pool.length&&this.allCompletedCallback()}),t.run()}}stop(t){return this.isStopped=!0,t&&t(this.pool),new Promise(t=>this.stopReslove=t)}}class n{constructor(t=1){this.concurrency=t,this.taskId=0,this.taskQueue=new e,this.taskRunner=new i(this.taskQueue,this.concurrency)}setConcurrency(t){this.concurrency=t,this.taskRunner.setConcurrency(t)}add(t,e,i="default"){const n=new s({id:this.taskId++,tag:i,params:e,taskFunction:t});return this.taskQueue.add(n),n}}t.CoroutineWStart=class extends n{constructor(t=1){super(t),this.status="stop"}append(t,s,e="default"){const i=this.add(t,s,e);return"running"===this.status&&this.taskRunner.run(),i}start(t=null){this.status="running",this.taskRunner.setTaskCompletedCallback(s=>"function"==typeof t&&t(s)),this.taskRunner.run()}stop(t){return this.status="stop",this.taskRunner.stop(t)}},t.CoroutineWait=class extends n{constructor(t=1){super(t)}wait(t=null){return new Promise(s=>{this.taskRunner.setTaskCompletedCallback(s=>"function"==typeof t&&t(s)),this.taskRunner.setAllCompletedCallback(()=>s(this.taskQueue)),this.taskRunner.run()})}},t.Lock=class{constructor(t=1){this.concurrency=t,this.promiseList=[],this.resolveList=[]}setConcurrency(t){this.concurrency=t}getConcurrency(){return this.concurrency}createPromiseAndResolve(){let t=new Promise(t=>this.resolveList.push(t));this.promiseList.push(t)}getPromise(){if(this.promiseList.length>=this.concurrency)return this.promiseList.shift()}getResolve(){return this.resolveList.shift()}async acquire(){const t=this.getPromise();this.createPromiseAndResolve(),t&&await t}release(){const t=this.getResolve();if(!t)throw new Error("Lock: release error");t(!0)}},t.Task=s,t.TaskQueue=e,t.TaskRunner=i});
//# sourceMappingURL=index.umd.js.map
