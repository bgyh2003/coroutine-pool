{"version":3,"file":"index.cjs.js","sources":["../src/task.ts","../src/task-queue.ts","../src/task-runner.ts","../src/coroutine-abstract.ts","../src/coroutine-start.ts","../src/coroutine-wait.ts","../src/lock.ts"],"sourcesContent":["\r\nimport type { ITaskData, ITaskFunction } from \"./types\"\r\n\r\nexport class Task<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> {\r\n\r\n    id: number\r\n    tag: string | null\r\n    params: TParams\r\n    taskFunction: ITaskFunction<TParams, TResult>\r\n\r\n    result: TResult | null = null\r\n    error: Error | null = null\r\n    isCompleted: boolean = false\r\n    isRunning: boolean = false\r\n    time: number = 0\r\n\r\n    completeCallback: (task: Task<TParams, TResult>) => void = () => { }\r\n\r\n    constructor(taskData: ITaskData<TParams, TResult>) {\r\n        this.id = taskData.id\r\n        this.tag = taskData.tag\r\n        this.params = taskData.params\r\n        this.taskFunction = taskData.taskFunction\r\n    }\r\n\r\n    async run() {\r\n\r\n        const start = Date.now()\r\n        try {\r\n            this.isRunning = true\r\n            this.result = await this.taskFunction(...this.params)\r\n        } catch (error) {\r\n            this.error = error as Error\r\n        } finally {\r\n            this.isRunning = false\r\n            this.isCompleted = true\r\n            this.time = Date.now() - start\r\n            this.completeCallback(this)\r\n        }\r\n\r\n    }\r\n\r\n    onComplete(callback: (task: Task<TParams, TResult>) => void) {\r\n        this.completeCallback = callback\r\n    }\r\n}\r\n\r\n\r\n","import type { ITaskData } from \"./types\"\r\nimport { Task } from \"./task\"\r\n\r\n\r\nexport class TaskQueue<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> {\r\n    constructor(\r\n        public tasks: Task<TParams, TResult>[] = []\r\n    ) { }\r\n\r\n    create(taskData: ITaskData<TParams, TResult>) {\r\n        const task = new Task(taskData)\r\n        this.tasks.push(task)\r\n        return task\r\n    }\r\n\r\n    add(task: Task<TParams, TResult>) { \r\n        this.tasks.push(task)\r\n    }\r\n\r\n    pop() {\r\n        return this.tasks.shift() || null\r\n    }\r\n\r\n    removeById(id: number) {\r\n        this.tasks = this.tasks.filter(task => task.id !== id)\r\n    }\r\n\r\n    removeByTag(tag: string) {\r\n        this.tasks = this.tasks.filter(task => task.tag !== tag)\r\n    }\r\n\r\n    remove(task: Task<TParams, TResult>) {\r\n        this.tasks = this.tasks.filter(t => t !== task)\r\n    }\r\n\r\n    clear() {\r\n        this.tasks = []\r\n    }\r\n\r\n}","import { TaskQueue } from \"./task-queue\"\r\nimport { Task } from \"./task\"\r\n\r\nexport class TaskRunner<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> {\r\n\r\n    isStopped: boolean = false\r\n    stopReslove: (() => void) | null = null\r\n\r\n    pool: Task<TParams, TResult>[] = []\r\n\r\n    taskCompletedCallback: (task: Task<TParams, TResult>) => void = () => { }\r\n\r\n    allCompletedCallback: () => void = () => { }\r\n\r\n    constructor(\r\n        public taskQueue: TaskQueue<TParams, TResult> = new TaskQueue<TParams, TResult>(),\r\n        public concurrency: number = 1\r\n    ) { }\r\n\r\n    setConcurrency(concurrency: number) {\r\n        this.concurrency = concurrency\r\n        this.run()\r\n    }\r\n\r\n    setTaskCompletedCallback(callback: (task: Task<TParams, TResult>) => void) {\r\n        this.taskCompletedCallback = callback\r\n    }\r\n\r\n    setAllCompletedCallback(callback: () => void) {\r\n        this.allCompletedCallback = callback\r\n    }\r\n\r\n    run() {\r\n\r\n        this.isStopped = false\r\n\r\n        while (this.pool.length < this.concurrency) {\r\n\r\n            // 提取任务\r\n            const task = this.taskQueue.pop()\r\n\r\n            // 没有任务则结束\r\n            if (!task) break\r\n\r\n            // 放入任务运行池\r\n            this.pool.push(task)\r\n\r\n            // 监听任务完成\r\n            task.onComplete((_task) => {\r\n\r\n                // 当前任务完成回调\r\n                this.taskCompletedCallback(_task)\r\n\r\n                // 清除当前完成的任务\r\n                this.pool = this.pool.filter(t => t !== _task)\r\n\r\n                // 如果任务已停止，则结束\r\n                if (this.isStopped) {\r\n\r\n                    if (this.pool.length === 0) {\r\n                        this.stopReslove && this.stopReslove()\r\n                        this.stopReslove = null\r\n                    }\r\n\r\n                    return\r\n                }\r\n\r\n                // 如果任务队列还有任务，继续执行\r\n                if (this.taskQueue.tasks.length > 0) this.run()\r\n\r\n                // 如果任务队列没有任务，且运行池也没有任务了，说明所有任务都完成了\r\n                else if (this.pool.length === 0) this.allCompletedCallback()\r\n\r\n            })\r\n\r\n            // 执行任务\r\n            task.run()\r\n\r\n        }\r\n    }\r\n\r\n    stop(callback?: (tasks: Task<TParams, TResult>[]) => void) {\r\n        this.isStopped = true\r\n\r\n        if (callback) callback(this.pool)\r\n\r\n        return new Promise<void>(resolve => this.stopReslove = resolve)\r\n    }\r\n\r\n}\r\n","import { Task, TaskQueue, TaskRunner } from \"./index\"\r\nimport { ITaskData } from \"./types\"\r\n\r\nexport default abstract class CoroutineAbstract<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> {\r\n\r\n    taskQueue: TaskQueue<TParams, TResult>\r\n    taskRunner: TaskRunner<TParams, TResult>\r\n    taskId: number = 0\r\n\r\n    constructor(\r\n        public concurrency: number = 1\r\n    ) {\r\n        this.taskQueue = new TaskQueue()\r\n        this.taskRunner = new TaskRunner(this.taskQueue, this.concurrency)\r\n    }\r\n\r\n    setConcurrency(concurrency: number) {\r\n        this.concurrency = concurrency\r\n        this.taskRunner.setConcurrency(concurrency)\r\n    }\r\n\r\n    add(\r\n        taskFunction: ITaskData<TParams, TResult>[\"taskFunction\"],\r\n        params: ITaskData<TParams, TResult>[\"params\"],\r\n        tag: ITaskData<TParams, TResult>[\"tag\"] = \"default\",\r\n\r\n    ) {\r\n        const task = new Task<TParams, TResult>({ id: this.taskId++, tag, params, taskFunction })\r\n        this.taskQueue.add(task)\r\n        return task\r\n    }\r\n\r\n}","import { Task, TaskQueue, TaskRunner } from \"./index\"\r\nimport { ITaskData } from \"./types\"\r\n\r\nimport CoroutineAbstract from \"./coroutine-abstract\"\r\n\r\n\r\nexport class CoroutineWStart<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> extends CoroutineAbstract<TParams, TResult> {\r\n\r\n    status: \"stop\" | \"running\" = \"stop\"\r\n\r\n    constructor(concurrency: number = 1) {\r\n        super(concurrency)\r\n    }\r\n\r\n    append(\r\n        taskFunction: ITaskData<TParams, TResult>[\"taskFunction\"],\r\n        params: ITaskData<TParams, TResult>[\"params\"],\r\n        tag: ITaskData<TParams, TResult>[\"tag\"] = \"default\"\r\n    ) {\r\n        const task = this.add(taskFunction, params, tag)\r\n        this.status === \"running\" && this.taskRunner.run()\r\n        return task\r\n    }\r\n\r\n    start(fn: ((task: Task<TParams, TResult>) => void) | null = null) {\r\n        this.status = \"running\"\r\n        this.taskRunner.setTaskCompletedCallback((task) => typeof (fn) === \"function\" && fn(task))\r\n        this.taskRunner.run()\r\n    }\r\n\r\n    stop(callback?: (tasks: Task<TParams, TResult>[]) => void) {\r\n        this.status = \"stop\"\r\n        return this.taskRunner.stop(callback)\r\n    }\r\n\r\n}","import { Task, TaskQueue, TaskRunner } from \"./index\"\r\nimport CoroutineAbstract from \"./coroutine-abstract\"\r\n\r\n\r\nexport class CoroutineWait<\r\n    TParams extends any[] = any[],\r\n    TResult = any\r\n> extends CoroutineAbstract<TParams, TResult> {\r\n\r\n    constructor(concurrency: number = 1) {\r\n        super(concurrency)\r\n    }\r\n\r\n    wait(fn: ((task: Task<TParams, TResult>) => void) | null = null) {\r\n        return new Promise<TaskQueue<TParams, TResult>>((resolve) => {\r\n            this.taskRunner.setTaskCompletedCallback((task) => typeof (fn) === \"function\" && fn(task))\r\n            this.taskRunner.setAllCompletedCallback(() => resolve(this.taskQueue))\r\n            this.taskRunner.run()\r\n        })\r\n    }\r\n}","\r\nexport class Lock {\r\n\r\n    private promiseList: Promise<any>[] = []\r\n\r\n    private resolveList: ((value: unknown) => void)[] = []\r\n\r\n    constructor(\r\n        private concurrency: number = 1\r\n    ) { }\r\n\r\n    setConcurrency(concurrency: number) {\r\n        this.concurrency = concurrency\r\n    }\r\n\r\n    getConcurrency() {\r\n        return this.concurrency\r\n    }\r\n\r\n    createPromiseAndResolve() {\r\n        let promise = new Promise((resolve) => this.resolveList.push(resolve))\r\n        this.promiseList.push(promise)\r\n    }\r\n\r\n    getPromise() {\r\n        if (this.promiseList.length >= this.concurrency)\r\n            return this.promiseList.shift()\r\n    }\r\n\r\n    getResolve() {\r\n        return this.resolveList.shift()\r\n    }\r\n\r\n    async acquire() {\r\n        const promise = this.getPromise()\r\n        this.createPromiseAndResolve()\r\n        if (promise) await promise\r\n    }\r\n\r\n    release() {\r\n        const resolve = this.getResolve()\r\n        if (resolve) resolve(true)\r\n        else throw new Error('Lock: release error')\r\n    }\r\n\r\n\r\n}"],"names":["Task","constructor","taskData","this","result","error","isCompleted","isRunning","time","completeCallback","id","tag","params","taskFunction","run","start","Date","now","onComplete","callback","TaskQueue","tasks","create","task","push","add","pop","shift","removeById","filter","removeByTag","remove","t","clear","TaskRunner","taskQueue","concurrency","isStopped","stopReslove","pool","taskCompletedCallback","allCompletedCallback","setConcurrency","setTaskCompletedCallback","setAllCompletedCallback","length","_task","stop","Promise","resolve","CoroutineAbstract","taskId","taskRunner","super","status","append","fn","wait","promiseList","resolveList","getConcurrency","createPromiseAndResolve","promise","getPromise","getResolve","acquire","release","Error"],"mappings":"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"}